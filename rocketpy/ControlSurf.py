import numpy as np
import math
from scipy.interpolate import interp1d

class ControlSurf:
    # Define Class Attributes
    
    def __init__(self, h, D, Rotation):
        
        """ Initialise ControlSurf class. This represents a single control surface.

        Parameters
        ----------
        D : scalar
            Rocket Diameter at the point at which the control surface is placed
        h : scalar
            Distance along the Rockets Z axis from the COM to the control surface.
            If the control surface is above the COM then h > 0
        Theta : scalar
            Angle in RADIANS about the Rocket Z axis measured from the Rocket X axis.
            For example, 4 equally spaced Control Surfaces might have Theta = 0, pi/2, pi, 3pi/4
        Phi : scalar 
            Angle in RADIANS of the control surface"""

        self.D = D 
        self.h = h
        self.Theta = Rotation
        self.Phi = 0
        with open("data/proxima/proximaDragCurve.csv") as file_name:
            array = np.loadtxt(file_name, delimiter=",")
        arrayT = array.T
        self.y_interp = interp1d(arrayT[0], arrayT[1])

    def getForceVec(self, u,t):
        """ Returns the force vector and point of application relative to the control surface base
        in the control surface frame"""
        # Dummy Values for the forces and position
        Rho = 1.2
        A =  0.00325
        CD = self.getCD()

        Fx = 0
        #Fy = -50*math.sin(self.Phi)
        Fy = -(Rho*A*CD*u*u)/2.0
        Fz = 0
        x = 0.1
        y = 0
        z = 0

        # print(str(t) + "," + str(Fy) + "," + str(u))
        return [Fx, Fy, Fz, x, y, z]

    def getCD(self):

        angle = abs(self.Phi*180.0/math.pi)
        return self.y_interp(angle)

    def getForceMoment(self,u,t):
        """Returns the resultant forces and moments generated by the control surface
        in the Rocket frame"""
        # Rotation from frame A to R (V_R = R_AR*V_A)
        R_AR = np.array([[math.cos(self.Theta), -math.cos(self.Theta), 0],
        [math.sin(self.Theta), math.cos(self.Theta), 0],
        [0, 0, 1]])

        # Rotation from frame B to A (eg V_A = R_BA*V_B)
        R_BA = np.array([[1, 0, 0],
        [0, math.cos(self.Phi), -math.sin(self.Phi)],
        [0, math.sin(self.Phi), math.cos(self.Phi)]])

        Fx, Fy, Fz, x, y, z = self.getForceVec(u,t)

        # Get forces in frame R
        F_B = np.array([Fx, Fy, Fz])
        F_R = R_AR.dot(R_BA).dot(F_B)

        # Find vector from COM (point O) to point of force application on control surface (point P)
        r_OC_R = np.array([0.5*math.cos(self.Theta)*self.D, 0.5*math.sin(self.Theta)*self.D, self.h])
        r_CP_B = np.array([x, y, z])
        r_OP_R = r_OC_R + R_AR.dot(R_BA).dot(r_CP_B)

        # Find Moments about COM
        M_R = np.cross(r_OP_R, F_R)

        return np.concatenate((F_R, M_R), axis=None)

    def setAngle(self, Phi):
        self.Phi = Phi